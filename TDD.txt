테스트 코드 쪽에 개선사항이나 나중에 고쳐야 할 사항을 적어놓는 것도 좋은 방법일 것 같다.

EXPECT_TRUE 같은 검증용 예약어 같은 경우는 그 파일내에서만 사용하고 fixture나 다른 함수에서 사용하는건
나중에 가독성의 문제가 생길 가능성이 있다. 한군데로 모으면 코드량이 줄긴 한데 보기가 어렵고 따라가야 
하는데 테스트의 특성상 테스트 코드를 함수따라 분석하고 있으면 쉽게 피로해지기 때문이다.

테스트와 실제 코드파일을 1:1로 매칭 했을때의 이점은, 테스트 코드는 명확성을 위해서 길게 만드는 것이 허용
된다는 것이다. 1:1로 매칭 하지 않고 fixture를 한군데 몰아 넣고 임의의 cpp로 다량의 테스트를 진행하는 경우
테스트가 긴것이 싫어지기 때문에 시나리오 테스트를 대부분 하게 되는데, 이때 코드의 가독성이 현저히 떨어지
게 된다. 특히나 테스트 코드의 경우 하드 코딩된 것들이 많은데 하드 코딩된 코드를 몇십줄 계속 보면 짜증이 올
라오기 때문이다. 테스트 코드는 짧게 딱 필요한 만큼만 보여주고 바로바로 인식 가능한 수준이어야 만들때도
부담없고 볼때도 부담없다. 테스트 코드는 보기 위해서 존재하는 것이기 때문에 책임이 간결하면서 명확하게,
추적이 쉽게, 실패가 되었을때 바로 가능해야 한다. 테스트 코드를 들여다 보는 시점은 작성하고나서 몇주, 몇달
뒤가 될텐데, 이때 실제 코드를 보는 것도 짜증나는데 테스트 코드를 분석해야 한다는 그 부담감이 tdd를 멀어지
게 하는 것이다. 그래서 시나리오 테스트는 꼭 필요한 것만, 최대한 짧은 흐름으로 해야 한다.

테스트 코드내 cpp에서는 주석을 적극적으로 사용하자. 여기는 테스트 하는 코드이기도 하지만, 기술문서의
성격도 같이 가지고 있기 때문에, 주석을 기피할 필요가 없다.

테스트 코드 내에 헬퍼 함수가 길어지면 이 코드를 분석하게 된다. 그러면 tdd의 본질에 반하는 것이기 때문에
tdd 코드는 은닉이 되는 함수를 만들지 말고, 표현되는 함수를 만들어야 한다. 예를들어, 
SimulateClick(button); 
이것은 클릭을 하는 것, 3번의 행동이 들어가 있지만 함수의 이름을 보고 3번의 행동이 있을 것임을 예측가능하다.
AttachTwoComponents(root, childA, childB);
이것은 두개의 컴포넌트가 어떻게 붙었는지, 또 위치가 어떻게 되는지, 어떤 정렬인지 등등을 알아야 한다면
이 함수를 열어보아야 한다. tdd 코드는 읽는 행위에 중점을 두고 있기 때문에 이렇게 함수를 '열어'보아야 한다
면 이 tdd 헬퍼함수는 잘못 만들어진 함수다.
레거시 코드에서는 은닉과 표현 둘다를 써서 코딩하지만, tdd 코드에서는 표현 코딩만 사용하자.
(표현코딩의 간단한 예시라면 한두줄짜리 인라인 같은 거라고 봐도 무방하다.)

코딩중에 버그가 생겨서 버그를 재현하기 위한 테스트코드를 만들수 있다. 이건 논리적인 테스트가 아니라 단지
버그를 잡기 위한 테스트 코드인데, 잡고 나면 테스트 코드를 삭제하면 된다. 혹시 이 테스트 코드가 논리적으로
검증이 안된 부분이었다면 남겨놓고, 검증코드가 있는데 여기만 발생하는 것이면, 이 부분을 수정하면 다시는 
이런일이 없기 때문이다. 

component에서 마우스 드래그 했을때 테스트가 안되는 현상을 발견했고, 그 이유를 찾아보니 마우스 드래그 
했을때 그 변화값을 컴포넌트 안에서 마우스를 가져와서 계산하고 있었다. 마우스의 움직임을 감지하는 것은
UIModule의 책임인데 component가 아직 그것의 일정 부분을 사용하고 있었기 때문이다. 그러니까 단일 책임
원칙이 지켜지지 않아 테스트가 안되는 현상이었던 것이다. 물론 전역에서 마우스 이동을 셋팅하고 테스트를
해 줄수도 있지만, 테스트는 그 클래스에서 시작과 완결을 기본으로 하기 때문에 그것이 이상했고, 그 이상함은
마우스의 처리가 단일원칙 위반에서 비롯된 것임을 알게되었다. 이렇듯 tdd는 oop를 강제한다.

tdd를 사용하면 내부에 assert로 해서 하지 말아야 할 것을 지정할수도 있지만, 이건 구현의 문제라서 의도를 
나타내는것은 어렵다. 즉, 코드가 변해가면 결국 처음의 assert를 한 의도가 점점 알수 어렵게 되고, 결국 assert
자체가 생각하게 만들게 된다. 하지만 tdd로 밖에서 테스트를 한 경우에는 구현의 중점을 둔게 아니라 의도에
중점을 둔 것이기 때문에 코드가 변해감에 따라서 자연스럽게 변하게 되고 의도를 나타내고 있기 때문에 달라
질 가능성이 적어진다. 그리고 레거시 코드가 주석으로 변해가서 지저분해지는 것을 막을 수 있고, 개별적으로
테스트를 하기 때문에 굳이 내부에 주석을 쓸 필요도 없어지게 된다. 대신 외부에 쓸공간이 tdd로 마련돼 있기
때문에 여기에서는 충분히 그 의도와 주석을 꼼꼼히 달아 놓으면 다음에 볼때에 큰 무리 없이 볼수 있게 된다.

tdd는 일기장 같은 느낌이다. 개발하면서 이것을 개발했을때의 생각과 느낌을 적어 놓을수 있는 공간이자,
그것을 테스트를 통해서 단지 글만이 아니라 그것을 실제로 테스트도 하기 때문에 살아있는 주석이 되는 것이다.
tdd코드 뿐만 아니라 주석도 각 tdd 하는 곳에 꼼꼼히 달아놓는 습관을 기르면 추후에 분석할때 큰 도움이 된다.

Region 관련 테스트를 하는데 UIModule이 Region을 관리하는데 UIModule은 Panel을 기본으로 가지는 구조이다.
그런데 이 구조 때문에 Panel을 자식으로 붙여서 Region 테스트를 하는게 가장 편한데, 반대로 이야기 한다면,
Panel에 의존하는 코드가 문제이다. 그렇다면 테스트도 그렇게 짤수 밖에 없는데, 그 말은 UIModule을 Locator로
분리해야 하지 않느냐 라는 문제에 당도하게 된다. Locator가 나을까 아니면 Adapter가 나을까 생각하다가 Adapter
로 했는데, Locator의 단점보다 Adapter의 단점이 더 크게 느껴지는것이 테스트를 통해서 확인할 수 있었다. 즉,
tdd를 하면서 테스트가 어딘가에 의존한다는 것은 프로그램을 다시 한번 돌아보는 계기를 마련해 주는 것이다.

tdd쪽 코드 정리나 클라이언트 코드 정리를 하고 있으면 때때로 무의미한 것이 아닌가 생각될때가 있는데,
추후에 크게 리팩토링 할때가 와서 리팩토링하면서 설계를 다시 짜서 맞추는 것이 가능한 것과, 그걸 하는데
걸리는 시간을 보면 깜짝 놀란다. 생각보다 엄청 빨리 되기 때문인데, 결국 코드 부채를 쌓지 않고 코딩 하면
나중에 안되는 부분이 되거나, 시간 감소효과를 톡톡히 볼수 있기 때문에, 코드 정리 및 리팩토링을 하는 것이
시간 낭비라고 생각된다면, 그것은 작은 프로젝트 일 경우에는 시간 낭비가 될 수 있지만, 적어도 3-4천줄만
넘어가더라도 tdd의 진가가 발휘되기 때문에 그정도로 작은 프로젝트의 경우에는 상관 없지만, 그렇지 않다면
리팩토링이나 코드 정리하는데 시간이 아깝다고 생각하지 말고, 코드 정리하는 시간을 어떻게 하면 빨리 할수
있을지를 강구해야 한다.

 audio manager를 만들때 SDL을 사용하는데, audio manager를 테스트 하고 싶었다. 그런데 tdd와 테스트를 두개를
 다르게 놓고 보아야 한다. tdd는 설계를 바꾸는데 사용하는 목적이 있는 것이고, 테스트는 잘 되는지 확인하는 것이기
 때문이다. audio manager는 tdd를 할 필요가 없다. 얘는 SDL의 함수를 가지고 약간의 조합을 거쳐서 manager로 만드는
 것이기 때문에 설계가 변동이 잦지 않을 뿐더러 클래스 크기도 크지 않다. 이런 경우에는 이 manager 클래스를 굳이
 tdd로 만들 필요는 없다. 하지만, 테스트 하면서 만들어야 한다. 이때는 tdd가 아닌 일반 테스트를 하면서 manager
 클래스를 만든다. 즉, mock을 쓰지 않고 소리를 들으면서 테스트를 한다. 속도도 빠를 필요도 없고 한번만 만들면 되고
 이 테스트는 놔두긴 하겠지만 실질적으로 많이 쓸모 있는건 아닐 것이다. 이런 테스트들은 ToyExpr에 모여 있다.
 처음에는 SDL을 virtual 함수로 싸서 만들까 생각했지만, 설계가 바뀌지 않고 크기가 작을 것이기에 굳이 tdd로 할 필요
 가 없고, 그렇기 때문에 interface나 virtual 함수를 써서 굳이 의존성을 떼어낼 필요가 없다. DirectXTK12도 이런 맥락
 에서 마찬가지이고, 그렇기에 Core 코드는 tdd 코드가 없다. 테스트 코드는 간혹 있을 순 있지만, 이 Core도 설계적으로
 간단하기 때문에 오류가 나거나 설계를 바꿔야 할때에는 약간의 리스크를 감수하면 된다. 그렇기 때문에 Core 코드는
 설계적으로 간단하고 직접적인 설계로 만들어야 할 것이다. 

 테스트 해야 하는 클래스와 테스트를 하지 말아야 하는 클래스를 보자 마자 알아야 할 정도로 습관이 돼 있어야 한다.
 즉 인터페이스 클래스와 구현 클래스를 바로 알아내는 것이 중요하다.

 회사에서 tdd를 꺼려 하는 이유는 관리비용일 것이다. 중복 테스트가 많으면 많을수록 인터페이스가 바뀌었을때
 테스트 코드를 바꾸어 주어야 하는 것들이 기하급수적으로 늘어나기 때문이다. 그리고 구현 코드 같은 경우에는
 tdd를 만들어도 만들때 하루 이틀을 제외하고 한번도 바뀌지 않는 코드들이 너무나 많다. 그것들을 위해서 tdd를
 만드는 것은 시간 낭비다. 하루 이틀 걸릴것은 기존의 방식으로 얼마든지 구현 가능하다. 그렇기 때문에 우리가 
 상업적으로 tdd를 쓰기 위해서는 tdd를 얼마나 tdd 개념에 맞게 쓰느냐도 물론 중요하지만, 상업적으로의 가이드
 라인이 있어야 한다. 어떤걸 쓰거나 어떤걸 쓰지 않는 것이 tdd를 완벽하게 구현하는가 만큼 중요한 것이다.

 tdd의 상업적 가이드 라인을 달성하기 위해서는 최대한 중복 테스트를 없애야 한다. 그러기 위해서는 몇개의 클래
 스를 관통하는 긴 테스트 보다 한개의 클래스만 테스트 하는 것을 목표로 하고, 물론 이 클래스가 private 한 성격
 을 가진 클래스라면 public-private-interface 라고 가정한다면 퍼블릭에서 호출하고 EXPECT_CALL 해서 interaface
 에서 잡아주는 형식을 취해야 한다. private 느낌이지만 public 함수로 테스트가 분명 가능할지라도, 이 함수가
 호출하는 클래스만 호출한다면 다른데 쓰일 일이 없기 때문에 굳이 이 클래스만 테스트할 필요가 없기 때문이다.
 혹여 이 함수가 나중에 다른 클래스에서 호출하게 된다면 그때 private 클래스는 interface 클래스로 성격이 바뀌며
 이때는 이 클래스만으로 테스트를 진행해야 중복이 없어지게 될 것이다.

 tdd는 public에서 호출해서 public으로 값을 확인 하는 것을 기본 전제로 둔다. 그리고 구현부 클래스는 테스트를 
 하지 않는 것을 기본으로 하며, Traverser 같이 함수의 모음, 즉 public과 구현부가 혼재해 있는 상황이 있을 수 있
 는데 이때는 Traverser를 리팩토링해 구현부와 public을 나누는 것도 생각해 볼 문제이다. 

 Traverser 클래스의 경우 클래스의 특성상 구현부와 public 함수가 혼재 돼 있는데, 이것을 구현부 클래스와 
 public 클래스로 나누고 public 클래스는 함수 테스트를 진행시키고 구현부는 그 윗단 클래스에서 테스트 하도록
 한다. c++23이면 패키지로 돼 있다면 알기 쉽게 할수 있으나, 지금은 코드를 보고 public 클래스인지 아닌지를
 유추하고, tdd에서 작성하지 않음으로써 구현부 클래스임을 명확하게 해야 할 것이다.